{"version":3,"sources":["webpack://Parchment/webpack/universalModuleDefinition","webpack://Parchment/webpack/bootstrap","webpack://Parchment/./src/scope.ts","webpack://Parchment/./src/collection/linked-list.ts","webpack://Parchment/./src/error.ts","webpack://Parchment/./src/registry.ts","webpack://Parchment/./src/blot/abstract/shadow.ts","webpack://Parchment/./src/blot/abstract/parent.ts","webpack://Parchment/./src/blot/abstract/container.ts","webpack://Parchment/./src/blot/abstract/leaf.ts","webpack://Parchment/./src/attributor/attributor.ts","webpack://Parchment/./src/attributor/class.ts","webpack://Parchment/./src/attributor/style.ts","webpack://Parchment/./src/attributor/store.ts","webpack://Parchment/./src/blot/inline.ts","webpack://Parchment/./src/blot/block.ts","webpack://Parchment/./src/blot/embed.ts","webpack://Parchment/./src/blot/scroll.ts","webpack://Parchment/./src/blot/text.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Scope","src_scope","linked_list","[object Object]","this","head","tail","length","nodes","insertBefore","append","apply","slice","index","next","iterator","cur","node","refNode","remove","prev","target","contains","curNode","ret","inclusive","callback","startNode","offset","find","curIndex","curLength","Math","min","reduce","memo","push","ParchmentError","Error","message","super","constructor","registry_Registry","attributes","classes","tags","types","bubble","blots","has","parentNode","scroll","input","match","query","blotClass","blot","Node","nodeType","TEXT_NODE","set","domNode","scope","ANY","Text","text","LEVEL","BLOCK","block","INLINE","inline","HTMLElement","getAttribute","split","some","tagName","TYPE","definitions","map","register","definition","blotName","attrName","keyName","className","Array","isArray","toUpperCase","forEach","tag","WeakMap","shadow_ShadowBlot","parseInt","toString","document","createElement","indexOf","classList","add","statics","cloneNode","parent","removeChild","delete","isolate","BLOT","wrap","ATTRIBUTE","format","def","ref","undefined","children","_context","requiredContainer","detach","replacement","_force","_mutations","wrapper","appendChild","shadow","parent_ParentBlot","uiNode","build","other","attach","child","uiClass","setAttribute","firstChild","from","childNodes","filter","reverse","makeAttachedBlot","err","forEachAt","childLength","deleteAt","criteria","descendant","Number","MAX_VALUE","descendants","lengthLeft","childIndex","concat","done","allowedChildren","BLOCK_BLOT","splitAfter","unwrap","formatAt","insertAt","childBlot","refBlot","refDomNode","nextSibling","targetParent","context","optimize","enforceAllowedChildren","defaultChild","position","path","moveChildren","replaceWith","force","after","clone","_length","mutations","addedNodes","removedNodes","mutation","type","body","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","sort","a","b","DOCUMENT_POSITION_FOLLOWING","e","replaceChild","abstract_parent","container_ContainerBlot","checkMerge","container","leaf_LeafBlot","_domNode","_inclusive","INLINE_BLOT","leaf","attributor_Attributor","item","options","attributeBit","whitelist","canAdd","_node","replace","removeAttribute","class_match","prefix","attributor_class","join","camelize","parts","rest","part","style","trim","store","attribute","keys","styles","attr","copy","inline_InlineBlot","toLowerCase","formats","values","obj1","obj2","prop","isEqual","update","move","block_BlockBlot","blot_embed","_scroll","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","MAX_OPTIMIZE_ITERATIONS","scroll_ScrollBlot","registry","observer","MutationObserver","observe","disconnect","mutationsMap","records","takeRecords","pop","mark","markParent","remaining","previousSibling","grandChild","blot_scroll","text_TextBlot","createTextNode","data","splitText","blot_text"],"mappings":"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","file":"parchment.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Parchment\"] = factory();\n\telse\n\t\troot[\"Parchment\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","var Scope;\n(function (Scope) {\n    Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n    Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n    Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n    Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n    Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n    Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n    Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n    Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n    Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n    Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n    Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n})(Scope || (Scope = {}));\nexport default Scope;\n","class LinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    append(...nodes) {\n        this.insertBefore(nodes[0], null);\n        if (nodes.length > 1) {\n            this.append.apply(this, nodes.slice(1));\n        }\n    }\n    at(index) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur && index > 0) {\n            index -= 1;\n            cur = next();\n        }\n        return cur;\n    }\n    contains(node) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            if (cur === node) {\n                return true;\n            }\n            cur = next();\n        }\n        return false;\n    }\n    indexOf(node) {\n        const next = this.iterator();\n        let cur = next();\n        let index = 0;\n        while (cur) {\n            if (cur === node) {\n                return index;\n            }\n            index += 1;\n            cur = next();\n        }\n        return -1;\n    }\n    insertBefore(node, refNode) {\n        if (node == null) {\n            return;\n        }\n        this.remove(node);\n        node.next = refNode;\n        if (refNode != null) {\n            node.prev = refNode.prev;\n            if (refNode.prev != null) {\n                refNode.prev.next = node;\n            }\n            refNode.prev = node;\n            if (refNode === this.head) {\n                this.head = node;\n            }\n        }\n        else if (this.tail != null) {\n            this.tail.next = node;\n            node.prev = this.tail;\n            this.tail = node;\n        }\n        else {\n            node.prev = null;\n            this.head = this.tail = node;\n        }\n        this.length += 1;\n    }\n    offset(target) {\n        let index = 0;\n        let cur = this.head;\n        while (cur != null) {\n            if (cur === target) {\n                return index;\n            }\n            index += cur.length();\n            cur = cur.next;\n        }\n        return -1;\n    }\n    remove(node) {\n        if (!this.contains(node)) {\n            return;\n        }\n        if (node.prev != null) {\n            node.prev.next = node.next;\n        }\n        if (node.next != null) {\n            node.next.prev = node.prev;\n        }\n        if (node === this.head) {\n            this.head = node.next;\n        }\n        if (node === this.tail) {\n            this.tail = node.prev;\n        }\n        this.length -= 1;\n    }\n    iterator(curNode = this.head) {\n        // TODO use yield when we can\n        return () => {\n            const ret = curNode;\n            if (curNode != null) {\n                curNode = curNode.next;\n            }\n            return ret;\n        };\n    }\n    find(index, inclusive = false) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            const length = cur.length();\n            if (index < length ||\n                (inclusive &&\n                    index === length &&\n                    (cur.next == null || cur.next.length() !== 0))) {\n                return [cur, index];\n            }\n            index -= length;\n            cur = next();\n        }\n        return [null, 0];\n    }\n    forEach(callback) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            callback(cur);\n            cur = next();\n        }\n    }\n    forEachAt(index, length, callback) {\n        if (length <= 0) {\n            return;\n        }\n        const [startNode, offset] = this.find(index);\n        let curIndex = index - offset;\n        const next = this.iterator(startNode);\n        let cur = next();\n        while (cur && curIndex < index + length) {\n            const curLength = cur.length();\n            if (index > curIndex) {\n                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n            }\n            else {\n                callback(cur, 0, Math.min(curLength, index + length - curIndex));\n            }\n            curIndex += curLength;\n            cur = next();\n        }\n    }\n    map(callback) {\n        return this.reduce((memo, cur) => {\n            memo.push(callback(cur));\n            return memo;\n        }, []);\n    }\n    reduce(callback, memo) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            memo = callback(memo, cur);\n            cur = next();\n        }\n        return memo;\n    }\n}\nexport default LinkedList;\n","export default class ParchmentError extends Error {\n    constructor(message) {\n        message = '[Parchment] ' + message;\n        super(message);\n        this.message = message;\n        this.name = this.constructor.name;\n    }\n}\n","import ParchmentError from './error';\nimport Scope from './scope';\nexport default class Registry {\n    constructor() {\n        this.attributes = {};\n        this.classes = {};\n        this.tags = {};\n        this.types = {};\n    }\n    static find(node, bubble = false) {\n        if (node == null) {\n            return null;\n        }\n        if (this.blots.has(node)) {\n            return this.blots.get(node) || null;\n        }\n        if (bubble) {\n            return this.find(node.parentNode, bubble);\n        }\n        return null;\n    }\n    create(scroll, input, value) {\n        const match = this.query(input);\n        if (match == null) {\n            throw new ParchmentError(`Unable to create ${input} blot`);\n        }\n        const blotClass = match;\n        const node = \n        // @ts-ignore\n        input instanceof Node || input.nodeType === Node.TEXT_NODE\n            ? input\n            : blotClass.create(value);\n        const blot = new blotClass(scroll, node, value);\n        Registry.blots.set(blot.domNode, blot);\n        return blot;\n    }\n    find(node, bubble = false) {\n        return Registry.find(node, bubble);\n    }\n    query(query, scope = Scope.ANY) {\n        let match;\n        if (typeof query === 'string') {\n            match = this.types[query] || this.attributes[query];\n            // @ts-ignore\n        }\n        else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n            match = this.types.text;\n        }\n        else if (typeof query === 'number') {\n            if (query & Scope.LEVEL & Scope.BLOCK) {\n                match = this.types.block;\n            }\n            else if (query & Scope.LEVEL & Scope.INLINE) {\n                match = this.types.inline;\n            }\n        }\n        else if (query instanceof HTMLElement) {\n            const names = (query.getAttribute('class') || '').split(/\\s+/);\n            names.some(name => {\n                match = this.classes[name];\n                if (match) {\n                    return true;\n                }\n                return false;\n            });\n            match = match || this.tags[query.tagName];\n        }\n        if (match == null) {\n            return null;\n        }\n        // @ts-ignore\n        if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) {\n            return match;\n        }\n        return null;\n    }\n    register(...definitions) {\n        if (definitions.length > 1) {\n            return definitions.map(d => {\n                return this.register(d);\n            });\n        }\n        const definition = definitions[0];\n        if (typeof definition.blotName !== 'string' &&\n            typeof definition.attrName !== 'string') {\n            throw new ParchmentError('Invalid definition');\n        }\n        else if (definition.blotName === 'abstract') {\n            throw new ParchmentError('Cannot register abstract class');\n        }\n        this.types[definition.blotName || definition.attrName] = definition;\n        if (typeof definition.keyName === 'string') {\n            this.attributes[definition.keyName] = definition;\n        }\n        else {\n            if (definition.className != null) {\n                this.classes[definition.className] = definition;\n            }\n            if (definition.tagName != null) {\n                if (Array.isArray(definition.tagName)) {\n                    definition.tagName = definition.tagName.map((tagName) => {\n                        return tagName.toUpperCase();\n                    });\n                }\n                else {\n                    definition.tagName = definition.tagName.toUpperCase();\n                }\n                const tagNames = Array.isArray(definition.tagName)\n                    ? definition.tagName\n                    : [definition.tagName];\n                tagNames.forEach((tag) => {\n                    if (this.tags[tag] == null || definition.className == null) {\n                        this.tags[tag] = definition;\n                    }\n                });\n            }\n        }\n        return definition;\n    }\n}\nRegistry.blots = new WeakMap();\n","import ParchmentError from '../../error';\nimport Registry from '../../registry';\nimport Scope from '../../scope';\nclass ShadowBlot {\n    constructor(scroll, domNode) {\n        this.scroll = scroll;\n        this.domNode = domNode;\n        Registry.blots.set(domNode, this);\n        this.prev = null;\n        this.next = null;\n    }\n    static create(value) {\n        if (this.tagName == null) {\n            throw new ParchmentError('Blot definition missing tagName');\n        }\n        let node;\n        if (Array.isArray(this.tagName)) {\n            if (typeof value === 'string') {\n                value = value.toUpperCase();\n                if (parseInt(value, 10).toString() === value) {\n                    value = parseInt(value, 10);\n                }\n            }\n            if (typeof value === 'number') {\n                node = document.createElement(this.tagName[value - 1]);\n            }\n            else if (this.tagName.indexOf(value) > -1) {\n                node = document.createElement(value);\n            }\n            else {\n                node = document.createElement(this.tagName[0]);\n            }\n        }\n        else {\n            node = document.createElement(this.tagName);\n        }\n        if (this.className) {\n            node.classList.add(this.className);\n        }\n        return node;\n    }\n    // Hack for accessing inherited static methods\n    get statics() {\n        return this.constructor;\n    }\n    attach() {\n        // Nothing to do\n    }\n    clone() {\n        const domNode = this.domNode.cloneNode(false);\n        return this.scroll.create(domNode);\n    }\n    detach() {\n        if (this.parent != null) {\n            this.parent.removeChild(this);\n        }\n        Registry.blots.delete(this.domNode);\n    }\n    deleteAt(index, length) {\n        const blot = this.isolate(index, length);\n        blot.remove();\n    }\n    formatAt(index, length, name, value) {\n        const blot = this.isolate(index, length);\n        if (this.scroll.query(name, Scope.BLOT) != null && value) {\n            blot.wrap(name, value);\n        }\n        else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n            const parent = this.scroll.create(this.statics.scope);\n            blot.wrap(parent);\n            parent.format(name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        const blot = def == null\n            ? this.scroll.create('text', value)\n            : this.scroll.create(value, def);\n        const ref = this.split(index);\n        this.parent.insertBefore(blot, ref || undefined);\n    }\n    isolate(index, length) {\n        const target = this.split(index);\n        if (target == null) {\n            throw new Error('Attempt to isolate at end');\n        }\n        target.split(length);\n        return target;\n    }\n    length() {\n        return 1;\n    }\n    offset(root = this.parent) {\n        if (this.parent == null || this === root) {\n            return 0;\n        }\n        return this.parent.children.offset(this) + this.parent.offset(root);\n    }\n    optimize(_context) {\n        if (this.statics.requiredContainer &&\n            !(this.parent instanceof this.statics.requiredContainer)) {\n            this.wrap(this.statics.requiredContainer.blotName);\n        }\n    }\n    remove() {\n        if (this.domNode.parentNode != null) {\n            this.domNode.parentNode.removeChild(this.domNode);\n        }\n        this.detach();\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(replacement, this.next || undefined);\n            this.remove();\n        }\n        return replacement;\n    }\n    split(index, _force) {\n        return index === 0 ? this : this.next;\n    }\n    update(_mutations, _context) {\n        // Nothing to do by default\n    }\n    wrap(name, value) {\n        const wrapper = typeof name === 'string'\n            ? this.scroll.create(name, value)\n            : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(wrapper, this.next || undefined);\n        }\n        if (typeof wrapper.appendChild !== 'function') {\n            throw new ParchmentError(`Cannot wrap ${name}`);\n        }\n        wrapper.appendChild(this);\n        return wrapper;\n    }\n}\nShadowBlot.blotName = 'abstract';\nexport default ShadowBlot;\n","import LinkedList from '../../collection/linked-list';\nimport ParchmentError from '../../error';\nimport Scope from '../../scope';\nimport ShadowBlot from './shadow';\nclass ParentBlot extends ShadowBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.uiNode = null;\n        this.build();\n    }\n    appendChild(other) {\n        this.insertBefore(other);\n    }\n    attach() {\n        super.attach();\n        this.children.forEach(child => {\n            child.attach();\n        });\n    }\n    attachUI(node) {\n        if (this.uiNode != null) {\n            this.uiNode.remove();\n        }\n        this.uiNode = node;\n        if (ParentBlot.uiClass) {\n            this.uiNode.classList.add(ParentBlot.uiClass);\n        }\n        this.uiNode.setAttribute('contenteditable', 'false');\n        this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    build() {\n        this.children = new LinkedList();\n        // Need to be reversed for if DOM nodes already in order\n        Array.from(this.domNode.childNodes)\n            .filter((node) => node !== this.uiNode)\n            .reverse()\n            .forEach((node) => {\n            try {\n                const child = makeAttachedBlot(node, this.scroll);\n                this.insertBefore(child, this.children.head || undefined);\n            }\n            catch (err) {\n                if (err instanceof ParchmentError) {\n                    return;\n                }\n                else {\n                    throw err;\n                }\n            }\n        });\n    }\n    deleteAt(index, length) {\n        if (index === 0 && length === this.length()) {\n            return this.remove();\n        }\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.deleteAt(offset, childLength);\n        });\n    }\n    descendant(criteria, index = 0) {\n        const [child, offset] = this.children.find(index);\n        if ((criteria.blotName == null && criteria(child)) ||\n            (criteria.blotName != null && child instanceof criteria)) {\n            return [child, offset];\n        }\n        else if (child instanceof ParentBlot) {\n            return child.descendant(criteria, offset);\n        }\n        else {\n            return [null, -1];\n        }\n    }\n    descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n        let descendants = [];\n        let lengthLeft = length;\n        this.children.forEachAt(index, length, (child, childIndex, childLength) => {\n            if ((criteria.blotName == null && criteria(child)) ||\n                (criteria.blotName != null && child instanceof criteria)) {\n                descendants.push(child);\n            }\n            if (child instanceof ParentBlot) {\n                descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft));\n            }\n            lengthLeft -= childLength;\n        });\n        return descendants;\n    }\n    detach() {\n        this.children.forEach(child => {\n            child.detach();\n        });\n        super.detach();\n    }\n    enforceAllowedChildren() {\n        let done = false;\n        this.children.forEach((child) => {\n            if (done) {\n                return;\n            }\n            const allowed = this.statics.allowedChildren.some((def) => child instanceof def);\n            if (allowed) {\n                return;\n            }\n            if (child.statics.scope === Scope.BLOCK_BLOT) {\n                if (child.next != null) {\n                    this.splitAfter(child);\n                }\n                if (child.prev != null) {\n                    this.splitAfter(child.prev);\n                }\n                child.parent.unwrap();\n                done = true;\n            }\n            else if (child instanceof ParentBlot) {\n                child.unwrap();\n            }\n            else {\n                child.remove();\n            }\n        });\n    }\n    formatAt(index, length, name, value) {\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.formatAt(offset, childLength, name, value);\n        });\n    }\n    insertAt(index, value, def) {\n        const [child, offset] = this.children.find(index);\n        if (child) {\n            child.insertAt(offset, value, def);\n        }\n        else {\n            const blot = def == null\n                ? this.scroll.create('text', value)\n                : this.scroll.create(value, def);\n            this.appendChild(blot);\n        }\n    }\n    insertBefore(childBlot, refBlot) {\n        if (childBlot.parent != null) {\n            childBlot.parent.children.remove(childBlot);\n        }\n        let refDomNode = null;\n        this.children.insertBefore(childBlot, refBlot || null);\n        if (refBlot != null) {\n            refDomNode = refBlot.domNode;\n        }\n        if (this.domNode.parentNode !== childBlot.domNode ||\n            this.domNode.nextSibling !== refDomNode) {\n            this.domNode.insertBefore(childBlot.domNode, refDomNode);\n        }\n        childBlot.parent = this;\n        childBlot.attach();\n    }\n    length() {\n        return this.children.reduce((memo, child) => {\n            return memo + child.length();\n        }, 0);\n    }\n    moveChildren(targetParent, refNode) {\n        this.children.forEach(child => {\n            targetParent.insertBefore(child, refNode);\n        });\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.enforceAllowedChildren();\n        if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n            this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n        }\n        if (this.children.length === 0) {\n            if (this.statics.defaultChild != null) {\n                const child = this.scroll.create(this.statics.defaultChild.blotName);\n                this.appendChild(child);\n                // TODO double check if necessary\n                // child.optimize(context);\n            }\n            else {\n                this.remove();\n            }\n        }\n    }\n    path(index, inclusive = false) {\n        const [child, offset] = this.children.find(index, inclusive);\n        const position = [[this, index]];\n        if (child instanceof ParentBlot) {\n            return position.concat(child.path(offset, inclusive));\n        }\n        else if (child != null) {\n            position.push([child, offset]);\n        }\n        return position;\n    }\n    removeChild(child) {\n        this.children.remove(child);\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (replacement instanceof ParentBlot) {\n            this.moveChildren(replacement);\n        }\n        return super.replaceWith(replacement);\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.clone();\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n            const split = child.split(offset, force);\n            if (split != null) {\n                after.appendChild(split);\n            }\n        });\n        return after;\n    }\n    splitAfter(child) {\n        const after = this.clone();\n        while (child.next != null) {\n            after.appendChild(child.next);\n        }\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        return after;\n    }\n    unwrap() {\n        if (this.parent) {\n            this.moveChildren(this.parent, this.next || undefined);\n        }\n        this.remove();\n    }\n    update(mutations, _context) {\n        const addedNodes = [];\n        const removedNodes = [];\n        mutations.forEach(mutation => {\n            if (mutation.target === this.domNode && mutation.type === 'childList') {\n                addedNodes.push.apply(addedNodes, mutation.addedNodes);\n                removedNodes.push.apply(removedNodes, mutation.removedNodes);\n            }\n        });\n        removedNodes.forEach((node) => {\n            // Check node has actually been removed\n            // One exception is Chrome does not immediately remove IFRAMEs\n            // from DOM but MutationRecord is correct in its reported removal\n            if (node.parentNode != null &&\n                // @ts-ignore\n                node.tagName !== 'IFRAME' &&\n                document.body.compareDocumentPosition(node) &\n                    Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                return;\n            }\n            const blot = this.scroll.find(node);\n            if (blot == null) {\n                return;\n            }\n            if (blot.domNode.parentNode == null ||\n                blot.domNode.parentNode === this.domNode) {\n                blot.detach();\n            }\n        });\n        addedNodes\n            .filter(node => {\n            return node.parentNode === this.domNode || node === this.uiNode;\n        })\n            .sort((a, b) => {\n            if (a === b) {\n                return 0;\n            }\n            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                return 1;\n            }\n            return -1;\n        })\n            .forEach(node => {\n            let refBlot = null;\n            if (node.nextSibling != null) {\n                refBlot = this.scroll.find(node.nextSibling);\n            }\n            const blot = makeAttachedBlot(node, this.scroll);\n            if (blot.next !== refBlot || blot.next == null) {\n                if (blot.parent != null) {\n                    blot.parent.removeChild(this);\n                }\n                this.insertBefore(blot, refBlot || undefined);\n            }\n        });\n        this.enforceAllowedChildren();\n    }\n}\nParentBlot.uiClass = '';\nfunction makeAttachedBlot(node, scroll) {\n    let blot = scroll.find(node);\n    if (blot == null) {\n        try {\n            blot = scroll.create(node);\n        }\n        catch (e) {\n            blot = scroll.create(Scope.INLINE);\n            Array.from(node.childNodes).forEach((child) => {\n                // @ts-ignore\n                blot.domNode.appendChild(child);\n            });\n            if (node.parentNode) {\n                node.parentNode.replaceChild(blot.domNode, node);\n            }\n            blot.attach();\n        }\n    }\n    return blot;\n}\nexport default ParentBlot;\n","import Scope from '../../scope';\nimport ParentBlot from './parent';\nclass ContainerBlot extends ParentBlot {\n    checkMerge() {\n        return (this.next !== null && this.next.statics.blotName === this.statics.blotName);\n    }\n    deleteAt(index, length) {\n        super.deleteAt(index, length);\n        this.enforceAllowedChildren();\n    }\n    formatAt(index, length, name, value) {\n        super.formatAt(index, length, name, value);\n        this.enforceAllowedChildren();\n    }\n    insertAt(index, value, def) {\n        super.insertAt(index, value, def);\n        this.enforceAllowedChildren();\n    }\n    optimize(context) {\n        super.optimize(context);\n        if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n            this.next.moveChildren(this);\n            this.next.remove();\n        }\n    }\n}\nContainerBlot.blotName = 'container';\nContainerBlot.scope = Scope.BLOCK_BLOT;\nexport default ContainerBlot;\n","import Scope from '../../scope';\nimport ShadowBlot from './shadow';\nclass LeafBlot extends ShadowBlot {\n    static value(_domNode) {\n        return true;\n    }\n    index(node, offset) {\n        if (this.domNode === node ||\n            this.domNode.compareDocumentPosition(node) &\n                Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return Math.min(offset, 1);\n        }\n        return -1;\n    }\n    position(index, _inclusive) {\n        const childNodes = Array.from(this.parent.domNode.childNodes);\n        let offset = childNodes.indexOf(this.domNode);\n        if (index > 0) {\n            offset += 1;\n        }\n        return [this.parent.domNode, offset];\n    }\n    value() {\n        return {\n            [this.statics.blotName]: this.statics.value(this.domNode) || true,\n        };\n    }\n}\nLeafBlot.scope = Scope.INLINE_BLOT;\nexport default LeafBlot;\n","import Scope from '../scope';\nexport default class Attributor {\n    static keys(node) {\n        return Array.from(node.attributes).map((item) => item.name);\n    }\n    constructor(attrName, keyName, options = {}) {\n        this.attrName = attrName;\n        this.keyName = keyName;\n        const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n        this.scope =\n            options.scope != null\n                ? // Ignore type bits, force attribute bit\n                    (options.scope & Scope.LEVEL) | attributeBit\n                : Scope.ATTRIBUTE;\n        if (options.whitelist != null) {\n            this.whitelist = options.whitelist;\n        }\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        node.setAttribute(this.keyName, value);\n        return true;\n    }\n    canAdd(_node, value) {\n        if (this.whitelist == null) {\n            return true;\n        }\n        if (typeof value === 'string') {\n            return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n        }\n        else {\n            return this.whitelist.indexOf(value) > -1;\n        }\n    }\n    remove(node) {\n        node.removeAttribute(this.keyName);\n    }\n    value(node) {\n        const value = node.getAttribute(this.keyName);\n        if (this.canAdd(node, value) && value) {\n            return value;\n        }\n        return '';\n    }\n}\n","import Attributor from './attributor';\nfunction match(node, prefix) {\n    const className = node.getAttribute('class') || '';\n    return className\n        .split(/\\s+/)\n        .filter(name => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n    static keys(node) {\n        return (node.getAttribute('class') || '').split(/\\s+/).map(name => name\n            .split('-')\n            .slice(0, -1)\n            .join('-'));\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        this.remove(node);\n        node.classList.add(`${this.keyName}-${value}`);\n        return true;\n    }\n    remove(node) {\n        const matches = match(node, this.keyName);\n        matches.forEach(name => {\n            node.classList.remove(name);\n        });\n        if (node.classList.length === 0) {\n            node.removeAttribute('class');\n        }\n    }\n    value(node) {\n        const result = match(node, this.keyName)[0] || '';\n        const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n        return this.canAdd(node, value) ? value : '';\n    }\n}\nexport default ClassAttributor;\n","import Attributor from './attributor';\nfunction camelize(name) {\n    const parts = name.split('-');\n    const rest = parts\n        .slice(1)\n        .map((part) => part[0].toUpperCase() + part.slice(1))\n        .join('');\n    return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n    static keys(node) {\n        return (node.getAttribute('style') || '').split(';').map(value => {\n            const arr = value.split(':');\n            return arr[0].trim();\n        });\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = value;\n        return true;\n    }\n    remove(node) {\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = '';\n        if (!node.getAttribute('style')) {\n            node.removeAttribute('style');\n        }\n    }\n    value(node) {\n        // @ts-ignore\n        const value = node.style[camelize(this.keyName)];\n        return this.canAdd(node, value) ? value : '';\n    }\n}\nexport default StyleAttributor;\n","import Registry from '../registry';\nimport Scope from '../scope';\nimport Attributor from './attributor';\nimport ClassAttributor from './class';\nimport StyleAttributor from './style';\nclass AttributorStore {\n    constructor(domNode) {\n        this.attributes = {};\n        this.domNode = domNode;\n        this.build();\n    }\n    attribute(attribute, value) {\n        // verb\n        if (value) {\n            if (attribute.add(this.domNode, value)) {\n                if (attribute.value(this.domNode) != null) {\n                    this.attributes[attribute.attrName] = attribute;\n                }\n                else {\n                    delete this.attributes[attribute.attrName];\n                }\n            }\n        }\n        else {\n            attribute.remove(this.domNode);\n            delete this.attributes[attribute.attrName];\n        }\n    }\n    build() {\n        this.attributes = {};\n        const blot = Registry.find(this.domNode);\n        if (blot == null) {\n            return;\n        }\n        const attributes = Attributor.keys(this.domNode);\n        const classes = ClassAttributor.keys(this.domNode);\n        const styles = StyleAttributor.keys(this.domNode);\n        attributes\n            .concat(classes)\n            .concat(styles)\n            .forEach(name => {\n            const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n            if (attr instanceof Attributor) {\n                this.attributes[attr.attrName] = attr;\n            }\n        });\n    }\n    copy(target) {\n        Object.keys(this.attributes).forEach(key => {\n            const value = this.attributes[key].value(this.domNode);\n            target.format(key, value);\n        });\n    }\n    move(target) {\n        this.copy(target);\n        Object.keys(this.attributes).forEach(key => {\n            this.attributes[key].remove(this.domNode);\n        });\n        this.attributes = {};\n    }\n    values() {\n        return Object.keys(this.attributes).reduce((attributes, name) => {\n            attributes[name] = this.attributes[name].value(this.domNode);\n            return attributes;\n        }, {});\n    }\n}\nexport default AttributorStore;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\n// Shallow object comparison\nfunction isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n    }\n    // @ts-ignore\n    for (const prop in obj1) {\n        // @ts-ignore\n        if (obj1[prop] !== obj2[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass InlineBlot extends ParentBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new AttributorStore(this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(InlineBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n        return undefined;\n    }\n    format(name, value) {\n        if (name === this.statics.blotName && !value) {\n            this.children.forEach(child => {\n                if (!(child instanceof InlineBlot)) {\n                    child = child.wrap(InlineBlot.blotName, true);\n                }\n                this.attributes.copy(child);\n            });\n            this.unwrap();\n        }\n        else {\n            const format = this.scroll.query(name, Scope.INLINE);\n            if (format == null) {\n                return;\n            }\n            if (format instanceof Attributor) {\n                this.attributes.attribute(format, value);\n            }\n            else if (value &&\n                (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                this.replaceWith(name, value);\n            }\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.formats()[name] != null ||\n            this.scroll.query(name, Scope.ATTRIBUTE)) {\n            const blot = this.isolate(index, length);\n            blot.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    optimize(context) {\n        super.optimize(context);\n        const formats = this.formats();\n        if (Object.keys(formats).length === 0) {\n            return this.unwrap(); // unformatted span\n        }\n        const next = this.next;\n        if (next instanceof InlineBlot &&\n            next.prev === this &&\n            isEqual(formats, next.formats())) {\n            next.moveChildren(this);\n            next.remove();\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some(mutation => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n    wrap(name, value) {\n        const wrapper = super.wrap(name, value);\n        if (wrapper instanceof InlineBlot) {\n            this.attributes.move(wrapper);\n        }\n        return wrapper;\n    }\n}\nInlineBlot.allowedChildren = [InlineBlot, LeafBlot];\nInlineBlot.blotName = 'inline';\nInlineBlot.scope = Scope.INLINE_BLOT;\nInlineBlot.tagName = 'SPAN';\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\nimport InlineBlot from './inline';\nclass BlockBlot extends ParentBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new AttributorStore(this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(BlockBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n    }\n    format(name, value) {\n        const format = this.scroll.query(name, Scope.BLOCK);\n        if (format == null) {\n            return;\n        }\n        else if (format instanceof Attributor) {\n            this.attributes.attribute(format, value);\n        }\n        else if (name === this.statics.blotName && !value) {\n            this.replaceWith(BlockBlot.blotName);\n        }\n        else if (value &&\n            (name !== this.statics.blotName || this.formats()[name] !== value)) {\n            this.replaceWith(name, value);\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.scroll.query(name, Scope.BLOCK) != null) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n            // Insert text or inline\n            super.insertAt(index, value, def);\n        }\n        else {\n            const after = this.split(index);\n            if (after != null) {\n                const blot = this.scroll.create(value, def);\n                after.parent.insertBefore(blot, after);\n            }\n            else {\n                throw new Error('Attempt to insertAt after block boundaries');\n            }\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some(mutation => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n}\nBlockBlot.blotName = 'block';\nBlockBlot.scope = Scope.BLOCK_BLOT;\nBlockBlot.tagName = 'P';\nBlockBlot.allowedChildren = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n];\nexport default BlockBlot;\n","import LeafBlot from './abstract/leaf';\nclass EmbedBlot extends LeafBlot {\n    static formats(_domNode, _scroll) {\n        return undefined;\n    }\n    format(name, value) {\n        // super.formatAt wraps, which is what we want in general,\n        // but this allows subclasses to overwrite for formats\n        // that just apply to particular embeds\n        super.formatAt(0, this.length(), name, value);\n    }\n    formatAt(index, length, name, value) {\n        if (index === 0 && length === this.length()) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    formats() {\n        return this.statics.formats(this.domNode, this.scroll);\n    }\n}\nexport default EmbedBlot;\n","import Registry from '../registry';\nimport Scope from '../scope';\nimport ContainerBlot from './abstract/container';\nimport ParentBlot from './abstract/parent';\nimport BlockBlot from './block';\nconst OBSERVER_CONFIG = {\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n};\nconst MAX_OPTIMIZE_ITERATIONS = 100;\nclass ScrollBlot extends ParentBlot {\n    constructor(registry, node) {\n        // @ts-ignore\n        super(null, node);\n        this.registry = registry;\n        this.scroll = this;\n        this.build();\n        this.observer = new MutationObserver((mutations) => {\n            this.update(mutations);\n        });\n        this.observer.observe(this.domNode, OBSERVER_CONFIG);\n        this.attach();\n    }\n    create(input, value) {\n        return this.registry.create(this, input, value);\n    }\n    find(node, bubble = false) {\n        return this.registry.find(node, bubble);\n    }\n    query(query, scope = Scope.ANY) {\n        return this.registry.query(query, scope);\n    }\n    register(...definitions) {\n        return this.registry.register(...definitions);\n    }\n    build() {\n        if (this.scroll == null) {\n            return;\n        }\n        super.build();\n    }\n    detach() {\n        super.detach();\n        this.observer.disconnect();\n    }\n    deleteAt(index, length) {\n        this.update();\n        if (index === 0 && length === this.length()) {\n            this.children.forEach(child => {\n                child.remove();\n            });\n        }\n        else {\n            super.deleteAt(index, length);\n        }\n    }\n    formatAt(index, length, name, value) {\n        this.update();\n        super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n        this.update();\n        super.insertAt(index, value, def);\n    }\n    optimize(mutations = [], context = {}) {\n        super.optimize(context);\n        const mutationsMap = context.mutationsMap || new WeakMap();\n        // We must modify mutations directly, cannot make copy and then modify\n        let records = Array.from(this.observer.takeRecords());\n        // Array.push currently seems to be implemented by a non-tail recursive function\n        // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n        while (records.length > 0) {\n            mutations.push(records.pop());\n        }\n        const mark = (blot, markParent = true) => {\n            if (blot == null || blot === this) {\n                return;\n            }\n            if (blot.domNode.parentNode == null) {\n                return;\n            }\n            if (!mutationsMap.has(blot.domNode)) {\n                mutationsMap.set(blot.domNode, []);\n            }\n            if (markParent) {\n                mark(blot.parent);\n            }\n        };\n        const optimize = (blot) => {\n            // Post-order traversal\n            if (!mutationsMap.has(blot.domNode)) {\n                return;\n            }\n            if (blot instanceof ParentBlot) {\n                blot.children.forEach(optimize);\n            }\n            mutationsMap.delete(blot.domNode);\n            blot.optimize(context);\n        };\n        let remaining = mutations;\n        for (let i = 0; remaining.length > 0; i += 1) {\n            if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                throw new Error('[Parchment] Maximum optimize iterations reached');\n            }\n            remaining.forEach((mutation) => {\n                const blot = this.find(mutation.target, true);\n                if (blot == null) {\n                    return;\n                }\n                if (blot.domNode === mutation.target) {\n                    if (mutation.type === 'childList') {\n                        mark(this.find(mutation.previousSibling, false));\n                        Array.from(mutation.addedNodes).forEach((node) => {\n                            const child = this.find(node, false);\n                            mark(child, false);\n                            if (child instanceof ParentBlot) {\n                                child.children.forEach((grandChild) => {\n                                    mark(grandChild, false);\n                                });\n                            }\n                        });\n                    }\n                    else if (mutation.type === 'attributes') {\n                        mark(blot.prev);\n                    }\n                }\n                mark(blot);\n            });\n            this.children.forEach(optimize);\n            remaining = Array.from(this.observer.takeRecords());\n            records = remaining.slice();\n            while (records.length > 0) {\n                mutations.push(records.pop());\n            }\n        }\n    }\n    update(mutations, context = {}) {\n        mutations = mutations || this.observer.takeRecords();\n        const mutationsMap = new WeakMap();\n        mutations\n            .map((mutation) => {\n            const blot = Registry.find(mutation.target, true);\n            if (blot == null) {\n                return null;\n            }\n            if (mutationsMap.has(blot.domNode)) {\n                mutationsMap.get(blot.domNode).push(mutation);\n                return null;\n            }\n            else {\n                mutationsMap.set(blot.domNode, [mutation]);\n                return blot;\n            }\n        })\n            .forEach((blot) => {\n            if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n                blot.update(mutationsMap.get(blot.domNode) || [], context);\n            }\n        });\n        context.mutationsMap = mutationsMap;\n        if (mutationsMap.has(this.domNode)) {\n            super.update(mutationsMap.get(this.domNode), context);\n        }\n        this.optimize(mutations, context);\n    }\n}\nScrollBlot.blotName = 'scroll';\nScrollBlot.defaultChild = BlockBlot;\nScrollBlot.allowedChildren = [BlockBlot, ContainerBlot];\nScrollBlot.scope = Scope.BLOCK_BLOT;\nScrollBlot.tagName = 'DIV';\nexport default ScrollBlot;\n","import Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nclass TextBlot extends LeafBlot {\n    constructor(scroll, node) {\n        super(scroll, node);\n        this.text = this.statics.value(this.domNode);\n    }\n    static create(value) {\n        return document.createTextNode(value);\n    }\n    static value(domNode) {\n        return domNode.data;\n    }\n    deleteAt(index, length) {\n        this.domNode.data = this.text =\n            this.text.slice(0, index) + this.text.slice(index + length);\n    }\n    index(node, offset) {\n        if (this.domNode === node) {\n            return offset;\n        }\n        return -1;\n    }\n    insertAt(index, value, def) {\n        if (def == null) {\n            this.text = this.text.slice(0, index) + value + this.text.slice(index);\n            this.domNode.data = this.text;\n        }\n        else {\n            super.insertAt(index, value, def);\n        }\n    }\n    length() {\n        return this.text.length;\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.text = this.statics.value(this.domNode);\n        if (this.text.length === 0) {\n            this.remove();\n        }\n        else if (this.next instanceof TextBlot && this.next.prev === this) {\n            this.insertAt(this.length(), this.next.value());\n            this.next.remove();\n        }\n    }\n    position(index, _inclusive = false) {\n        return [this.domNode, index];\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.scroll.create(this.domNode.splitText(index));\n        this.parent.insertBefore(after, this.next || undefined);\n        this.text = this.statics.value(this.domNode);\n        return after;\n    }\n    update(mutations, _context) {\n        if (mutations.some(mutation => {\n            return (mutation.type === 'characterData' && mutation.target === this.domNode);\n        })) {\n            this.text = this.statics.value(this.domNode);\n        }\n    }\n    value() {\n        return this.text;\n    }\n}\nTextBlot.blotName = 'text';\nTextBlot.scope = Scope.INLINE_BLOT;\nexport default TextBlot;\n"],"sourceRoot":""}